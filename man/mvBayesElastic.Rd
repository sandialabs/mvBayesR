% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvBayesElastic.R
\name{mvBayesElastic}
\alias{mvBayesElastic}
\title{Multivariate Elastic FDA Bayesian Regression}
\usage{
mvBayesElastic(
  bayesModel,
  X,
  Y,
  warpData = NULL,
  basisType = "jfpcah",
  nBasis = NULL,
  propVarExplained = 0.99,
  nCores = 1,
  samplesExtract = NULL,
  residSDExtract = NULL,
  idxSamplesArg = "idxSamples",
  srvf = FALSE,
  idx = NULL,
  ...
)
}
\arguments{
\item{bayesModel}{A Bayesian regression model-fitting function, with first argument taking an nxp input matrix or data.frame, and second argument taking an n-vector of numeric responses.}

\item{X}{A matrix of predictors of dimension nxp, where n is the number of training examples and p is the number of inputs (features).}

\item{Y}{A response matrix of dimension nxq, where q is the number of multivariate/functional responses.}

\item{warpData}{`time_warping` object from `fdasrvf` if `basisType=jfpca` or `jfpcah`}

\item{basisType}{The type of basis functions to use. Options are `jfpca`, `jfpcah`.}

\item{nBasis}{An integer specifying the number of basis functions to use. The default is NULL, in which case propVarExplained is used to choose nBasis.}

\item{propVarExplained}{Proportion (between 0 and 1) of variation to explain when choosing the number of principal components. Only used if nBasis is NULL (which is the default).}

\item{nCores}{An integer less than or equal to nBasis, specifying the number of threads to use when fitting independent Bayesian models.}

\item{samplesExtract}{function taking the output of bayesModel (`bm`) and extracting posterior samples of all parameters of interest. If `NULL`, mvBayes tries to access`bm$samples`; if unsuccessful, an object called `samples` is created with attribute `residSD`.}

\item{residSDExtract}{function taking the output of bayesModel (`bm`) and extracting posterior samples of the residual standard deviation (`residSD`). If `NULL``, mvBayes tries to access `bm$samples$residSD`; if unsuccessful, `residSD` is the  standard deviation of the residuals.}

\item{idxSamplesArg}{str Name of an optional argument of `predict` controlling which posterior samples are used for posterior prediction.}

\item{srvf}{use SRVF if `basisType=jfpca` or `jfpcah` default = TRUE}

\item{idx}{vector of indices to subset `warpData`}

\item{...}{Additional arguments to bayesModel.}
}
\value{
An object of class "mvBayes", which is a list containing "X", an object called "basisInfo" of class "basisSetup" containing information about the basis decomposition, "bayesModel", and "bmList", which contains a list of length nBasis containing fitted model objects for each basis component.
}
\description{
Wrapper to fit a elastic functional response, using an arbitrary univariate Bayesian regression model to independently fit basis components (e.g., principal components) of the response.
}
\details{
First uses the basisSetup function to decompose the response into nBasis components, then independently fits bayesModel to each of those components.
}
\examples{
## simulate data (Friedman function with first variable as functional)
f = function(x) {
  10 * sin(pi * x[, 1] * x[, 2]) + 20 * (x[, 3] - .5)^2 + 10 * x[, 4] + 5 *
    x[, 5]
}
sigma = 1 # noise sd
n = 500 # number of observations
n_grid = 50 # size of functional variable grid
t_grid = seq(0, 1, length.out = n_grid) # functional grid
X = matrix(runif(n * 9), n, 9) # 9 non-functional variables, only first 4 matter
X_expanded = cbind(rep(t_grid, each = n), kronecker(rep(1, n_grid), X)) # to get y
Y = matrix(f(X_expanded), nrow = n) + rnorm(n * n_grid, 0, sigma)

## fit Multivariate BASS
fit = mvBayes(
  BASS::bass, X, Y, nBasis = 3, # mvBayes parameters
  nburn = 8500, # bass parameter
  samplesExtract = function(bm) list(
    s2 = bm$s2,
    nbasis = bm$nbasis,
    beta.prec = bm$beta.prec
  ),
  idxSamplesArg = 'mcmc.use'
)
plot(fit$basisInfo, title = 'Principal Component Decomposition of Y')
traceplot(
  fit,
  modelParams = c('s2', 'nbasis', 'beta.prec'),
  labels = c(
    'sigma^2',
    'Number of BASS Basis Vectors',
    'Coefficient Precision'
  ),
  title = 'Traceplots of BASS parameters'
)
plot(fit, title = 'Multivariate BASS Model Fit')


## prediction
ntest = 1000
Xtest = matrix(runif(ntest * 9), ntest, 9)
Xtest_expanded = cbind(rep(t_grid, each = ntest), kronecker(rep(1, n_grid), Xtest))
Ytest = matrix(f(Xtest_expanded), nrow = ntest) + rnorm(ntest * n_grid, 0, sigma)
pred = predict(fit, Xtest) # posterior predictive samples (each is a curve)
plot(fit,
     Xtest = Xtest,
     Ytest = Ytest,
     title = 'Multivariate BASS Out-of-sample Predictions')


## cross-validation
cv = mvBayesCV(
  BASS::bass,
  X,
  Y,
  nTest = 100,
  nRep = 2,
  # mvBayesCV parameters
  nBasis = 3,
  # mvBayes parameters
  nburn = 8500 # bass parameters
)

## sensitivity
sens = mvSobol(fit, nMC = 2^12, totalSobol = FALSE) # use BASS functionality to compute mvSobol

## Write a wrapper for a non-conforming function to conform to mvBayes requirements
linmod = function(X, y, ...)
  structure(lm(y ~ X, ...), class = 'linmod')
predict.linmod = function(object, newdata)
  predict(structure(object, class = 'lm'), as.data.frame(newdata))
fit = mvBayes(
  linmod,
  X,
  Y,
  nBasis = 5,
  samplesExtract = function(bm) list(
    residSD = sd(bm$residuals)
  )
)
yhat = predict(fit, X)
}
\seealso{
\link{basisSetup} for computing the basis decomposition, \link{predict.mvBayes} for prediction, \link{plot.mvBayes} for plotting the model fit, \link{traceplot} for monitoring posterior convergence, and \link{mvSobol} for sensitivity analysis.
}
\keyword{analysis}
\keyword{bayesian}
\keyword{data}
\keyword{functional}
\keyword{modeling,}
\keyword{multivariate}
\keyword{regression}
